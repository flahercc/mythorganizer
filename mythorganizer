#! /bin/bash

###############################################################################
#read in file name from command line
#connect to mythtv db and get relavent information about recording
#check if there is an entry for show name in showtranslation file
#check if there is a season and episode
#if so create the showname
#if not get the thetvdb.com xml file
#clean up the xml file
#check if there is episode info
#if not use originalairdate to get info from xml file
#use xml parser to get the node of the information to create a temp xml file
#extract season and episode from temp xml file
#create the showname
#make show/season directory after checking if it already exists
#create a pointer to show directory
#generate com skip file
#inform Kodi about the new file
#exit
###############################################################################

#User Settings
#working directory
workingDir=~/.mythorganizer
#the directory to move tvshow file
tvDir=~/tv
#the directory to move movie files
movieDir=~/movies
#API key from www.thetvdb.com.
apiKey="9C42C2F2D2F613DD"
#Language setting
lang=en
#CommercialMarkup will generate comskip files for recordings when they are moved. Enabled|Disabled
comskip=Enabled
#Timeout for thetvdb.com
Timeout=50

##Conversion Settings##
#Convert the recording using avconv. Enabled|Disabled
convert=Enabled
LOGFILE=~/convert.log
tune="film"
nicevalue=0
profile="high"
level=41
videocodec="libx264"
preset="faster"
deinterlace=1
audiocodec="copy"
threads=2

#MythTV DB info
#The IP address or name of the server for MythTV Database (used in python bindings only)
dBHostName=localhost
#MySQL User name: Default="mythtv"
mySQLUser="mythtv" 
#MySQL Password: Default="mythtv"
mySQLPass="3YTWLTrA"
#MythTV Backend server: Default=localhost
mythTVBackendServer=localhost
#The Database Pin for the MythTV Database (used in python bindings only)
dBPin="0"
#If utilizing mythconverg with Python Bindings, then it would be MySQLMythDb=PythonBindingsmythconverg
mySQLMythDb=mythconverg

#Kodi Settings
kodiUpdate=Enabled
#Send a notification to kodi to cleanup the library upon Successful move job Enabled|Disabled
kodiClean=Enabled
#Send Notifications to kodi UI when library is updated Enabled|Disabled
kodiNotify=Enabled
#Ip Address and port for kodi Notifications Eg.kodiIPs=( "192.168.1.110:8080" "192.168.1.111:8080" "XBOX:8080" )
kodiIPs=( "192.168.1.130:8080" "192.168.1.112:8080" )

####Start Functions#####
ConvertRecording() {
  echo "Starting avconv at $(date)..." >>$LOGFILE
  echo "User running script is $(whoami)..." >>$LOGFILE
  echo "Converting $file..." >>$LOGFILE
  echo "nice -n $nicevalue avconv -v 16 -i $InputPath -c:v $videocodec -preset $preset -tune $tune -vf yadif -profile:v $profile -level $level -c:a $audiocodec -threads $threads $InputPath.mp4" >>$LOGFILE
  nice -n "$nicevalue" avconv -v 16 -i "$InputPath" -c:v "$videocodec" -preset "$preset" -tune "$tune" -vf yadif -profile:v "$profile" -level "$level" -c:a "$audiocodec" -threads "$threads" "$InputPath.mp4"
  # check if the transcode exited with an error; if not, delete the intermediate MPEG file and map
  if [ $? != 0 ]; then
    echo "Error occurred running avconv: input=$InputPath output=$InputPath.mp4" >>$LOGFILE
  else
    echo "Transcoding complete at $(date)!" >>$LOGFILE
    #rename the *.mpg file to *.mpg.old
    if [ -f "$InputPath.mp4" ]; then
      echo "Moving $InputPath to $InputPath.old" >>$LOGFILE
      mv "$InputPath" "$InputPath.old"
      echo "Moving $InputPath.mp4 to $InputPath" >>$LOGFILE
      mv "$InputPath.mp4" "$InputPath"
    else
      echo "Transcoded file missing!!!" >>$LOGFILE
    fi
  fi
  echo "" >>$LOGFILE

  #make sure the owner/group is mythtv
  chown mythtv:mythtv "$InputPath"

  #set it so anyone can delete the file (mostly from xbmc/kodi)
  chmod 666 "$InputPath"
}


GetRecordingInfo() {
  echo "Attemting to pull database information on $InputPath"

  #make a named pipe for database output
  test ! -p "$workingDir/dbout" && mkfifo "$workingDir/dbout" 

  #run the python bindings and output to named pipe
  /usr/local/bin/MythDataGrabber --filename="$InputFileBasename" --DBPin="$dBPin" --DBHostName="$dBHostName" --DBName="$mySQLMythDb" --DBUserName="$mySQLuser" --DBPassword="$mySQLpass"> "$workingDir/dbout" &
  pythonExitStatus=$?
  test "$pythonExitStatus" != "0" && echo "DATABASE ACCESS ERROR: COULD NOT OBTAIN INFORMATION \n Check DBInfo in mythicalSetup, verify file is mythtv file"

  #read values from named pipe, remove quotes and declare $Variable=$Value
  while read var equals value
  do 
    value=`echo $value|tr -d \"`
    test "$equals" = "=" && declare $var="$value"
    echo $var$equals$value
  done < "$workingDir/dbout" > /dev/null 2>&1
 
  #Import mythtv values into workingDir values, don't clobber title, subtitle.
  test "$InputTitle" = "" && InputTitle=$title
  test "$InputSubtitle" = "" && InputSubtitle=$subtitle; 
  #redefine database var names into workingDir var names
  MovieAirDate=$airdate
  OriginalAirDate=$originalairdate
  ShowCategory=$category
  Stars=$stars
  Plot=$description
  Zap2itSeriesID=$seriesid
  ProgramID=$programid
  ChanID=$chanid
  ShowStartTime=$starttime
  Season=$season
  Episode=$episode
  Inetref=$inetref
  
  #Create MV/EP/SH Identification Type from ProgramID
  progId=${ProgramID:0:2}
   
  #cleanup, remove the fifo named pipe
  test -p "$workingDir/dbout" && rm -f "$workingDir/dbout" 
}

GetXMLZip()  {
  #Search TheTvDb and return an XML file with results
  curl -L -s -m"$Timeout" "www.thetvdb.com/api/$apiKey/series/$seriesid/all/en.zip" > "$workingDir/$InputTitle.zip"
  #wget "www.thetvdb.com/api/$apiKey/series/$seriesid/all/en.zip"
  echo "Downloaded zip file from thetvdb.com for $seriesid"
  
  #unzip to /tmp
  unzip -o -d "$workingDir" "$workingDir/$InputTitle.zip"
  
  #Move xml file to working directory and rename
  mv "$workingDir/en.xml" "$workingDir/$InputTitle.xml"
  
  if [ -f "$workingDir/$InputTitle.xml" ]; then
    #extract the episode node from the xml
    echo "Extracting Episode node for $InputSubtitle from xml file"
    xmlstarlet sel -t -c "/Data/Episode[EpisodeName='$InputSubtitle']" "$workingDir/$InputTitle.xml" > "$workingDir/episode.xml"
  fi
}

CreateFileName() {
  #if it a movie just name it the movie title
  if [ $progId = "MV" ]
  then
    progfilename=$InputTitle"."$extension
    moveDir=$movieDir
  else
    SE=$Season"x"$Episode
    if [ "$InputSubtitle" != "" ]; then
      progfilename="$InputTitle - $SE - $InputSubtitle.$extension"
    else
      progfilename="$InputTitle - $SE - $filename.$extension"
    fi
    moveDir=$tvDir
  fi
}

RunComskip() {
  wine /home/mythtv/comskip/comskip.exe "$InputPath" > /dev/null 2>&1
  
  #move the comskip file to the destination directory
  mv "$recpath/$filename.txt" "$moveDir/$episodename.txt"
  mv "$recpath/$filename.edl" "$moveDir/$episodename.edl"
  mv "$recpath/$filename.log" "$moveDir/$episodename.log"
  
  #delete the logo file
  rm "$recpath/$filename.logo.txt"
  rm "$recpath/$filename.dif"
  
  return 0
}
 
UpdateKodi() {
  #Send notification to kodi, Update Library, Clean Library
  if [ "$kodiNotify" = "Enabled" -o "$kodiUpdate" = "Enabled" -o "$kodiClean" = "Enabled" ]; then
    for kodiIP in ${kodiIPs[@]}
    do
      echo "SENDING REQUESTED COMMANDS TO:$kodiIP"
      test "$kodiNotify" = "Enabled" && curl -L -s -m3 --connect-timeout 5 -X POST -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"GUI.ShowNotification","params":{"title":"mythical Librarian adding","message":"'$InputTitle'"},"id":1}' http://$kodiIP/jsonrpc > /dev/null 2>&1
      test "$kodiNotify" = "Enabled" && curl -L -s -m3 --connect-timeout 5 -X POST -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"VideoLibrary.Scan","id":1}' http://$kodiIP/jsonrpc > /dev/null 2>&1
      test "$kodiNotify" = "Enabled" && curl -L -s -m3 --connect-timeout 5 -X POST -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"VideoLibrary.Clean","id":1}' http://$kodiIP/jsonrpc > /dev/null 2>&1
    done
  fi
  return 0
}

CreateEpisodeNFO() {
  echo "<?xml version='1.0' encoding='UTF-8'?>" >> "$moveDir/$episodename.nfo"
  echo "<episodedetails>" >> "$moveDir/$episodename.nfo"
  if [ "$InputSubtitle" != "" ]; then
    echo "  <title>$InputSubtitle</title>" >> "$moveDir/$episodename.nfo"
  else
    echo "  <title>$InputTitle</title>" >> "$moveDir/$episodename.nfo"
  fi
  echo "  <season>$Season</season>" >> "$moveDir/$episodename.nfo"
  echo "  <episode>$Episode</episode>" >> "$moveDir/$episodename.nfo"
  echo "  <plot>$Plot</plot>" >> "$moveDir/$episodename.nfo"
  echo "  <aired>$OriginalAirDate</aired>" >> "$moveDir/$episodename.nfo"
  echo "  <playcount>0</playcount" >> "$moveDir/$episodename.nfo"
  echo "</episodedetails>" >> "$moveDir/$episodename.nfo"
  echo "Created  $moveDir/$episodename.nfo!"  
}

CreateSeriesNFO() {
  xmlstarlet sel -t -c "/Data/Series" "$workingDir/$InputTitle.xml" > "$workingDir/temp_tvshow.xml"
  
  #parse out the xml file
  if [ -f "$workingDir/temp_tvshow.xml" ]; then  
    while read line
    do
      #Get series name
      if [[ $line == \<SeriesName\>* ]]; then
        line=${line/<\/SeriesName>/}
        line=${line/<SeriesName>/}
        seriesname=$line
      #Get actors
      elif [[ $line == \<Actors\>* ]]; then
        line=${line/<\/Actors>/}
        line=${line/<Actors>/}
        actors=$line
      elif [[ $line == \<Rating\>* ]]; then
        line=${line/<\/Rating>/}
        line=${line/<Rating>/}
        rating=$line
      elif [[ $line == \<RatingCount\>* ]]; then
        line=${line/<\/RatingCount>/}
        line=${line/<RatingCount>/}
        votes=$line
      elif [[ $line == \<Overview\>* ]]; then
        line=${line/<\/Overview>/}
        line=${line/<Overview>/}
        plot=$line
      elif [[ $line == \<id\>* ]]; then
        line=${line/<\/id>/}
        line=${line/<id>/}
        tvdb_id=$line
      elif [[ $line == \<Genre\>* ]]; then
        line=${line/<\/Genre>/}
        line=${line/<Genre>/}
        genre=$line
      elif [[ $line == \<FirstAired\>* ]]; then
        line=${line/<\/FirstAired>/}
        line=${line/<FirstAired>/}
        premiered=$line
      #Get banner path
      elif [[ $line == \<Network\>* ]]; then
        line=${line/<\/Network>/}
        line=${line/<Network>/}
        studio=$line
      fi
    done < "$workingDir/temp_tvshow.xml"
  fi
  
  #writing tvshow.nfo
  echo "<?xml version='1.0' encoding='UTF-8'?>" >> "$moveDir/tvshow.xml"
  echo "<tvshow>" >> "$moveDir/tvshow.xml"
  echo "  <title>$seriesname</title>" >> "$moveDir/tvshow.xml"
  echo "  <actors>$actors</actors>" >> "$moveDir/tvshow.xml"
  echo "  <rating>$rating</rating>" >> "$moveDir/tvshow.xml"
  echo "  <votes>$votes</votes>" >> "$moveDir/tvshow.xml"
  echo "  <plot>$plot</plot>" >> "$moveDir/tvshow.xml"
  echo "  <id>$tvdb_id</id>" >> "$moveDir/tvshow.xml"
  echo "  <genre>$genre</genre>" >> "$moveDir/tvshow.xml"
  echo "  <studio>$studio</studio>" >> "$moveDir/tvshow.xml"
  echo "</tvshow>" >> "$moveDir/tvshow.xml"
  
  echo "Created $moveDir/tvshow.xml file!"
}

DownloadFanart() {
  if [ -f "$workingDir/temp_tvshow.xml" ]; then  
    while read line
    do
      #Get fanaart path
      if [[ $line == \<fanart\>* ]]; then
        line=${line/<\/fanart>/}
        line=${line/<fanart>/}
        fanartpath=$line
      #Get poster path
      elif [[ $line == \<poster\>* ]]; then
        line=${line/<\/poster>/}
        line=${line/<poster>/}
        posterpath=$line
      #Get banner path
      elif [[ $line == \<banner\>* ]]; then
        line=${line/<\/banner>/}
        line=${line/<banner>/}
        bannerpath=$line
      fi
    done < "$workingDir/temp_tvshow.xml"
  fi

  
  #check if they exist already and if not download them
  if [ ! -f "$moveDir/fanart.jpg" ]; then
    curl -L -s -m"$Timeout" "www.thetvdb.com/banners/$fanartpath" > "$moveDir/fanart.jpg"
    echo "Downloaded fanart from www.thetvdb.com/banners/$fanartpath"
  fi

  if [ ! -f "$moveDir/poster.jpg" ]; then
    curl -L -s -m"$Timeout" "www.thetvdb.com/banners/$posterpath" > "$moveDir/poster.jpg"
    echo "Downloaded poster from www.thetvdb.com/banners/$posterpath"
  fi
  
  if [ ! -f "$moveDir/banner.jpg" ]; then
    curl -L -s -m"$Timeout" "www.thetvdb.com/banners/$bannerpath" > "$moveDir/banner.jpg"
    echo "Downloaded banner from www.thetvdb.com/banners/$bannerpath"
  fi
  
}

GetSeriesId() {
  seriesid=${Inetref#*_}
  echo "Determined series id is $seriesid"
  
  return 0
}
  
GetSeasonAndEpisodeInfo() {
  if [ -f "$workingDir/episode.xml" ]; then  
    while read line
    do
      #Get Season number
      if [[ $line == \<SeasonNumber\>* ]]; then
        line=${line/<\/SeasonNumber>/}
        line=${line/<SeasonNumber>/}
        Season=$line
      #Get Episode number
      elif [[ $line == \<EpisodeNumber\>* ]]; then
        line=${line/<\/EpisodeNumber>/}
        line=${line/<EpisodeNumber>/}
        Episode=$line
      fi
    done < "$workingDir/episode.xml"
  fi
}

#####Make Show Folder#####
MakeShowDir() {
  #If specified, make $movedir = $movedir/show name
  if [ "$InputTitle" != "" ]; then
    moveDir="$moveDir/$InputTitle"
    if [ ! -d "$moveDir" ]; then
      echo "CREATING FOLDER: $moveDir">>"$workingDir"/output.log
      echo "$moveDir">>"$workingDir"/dir.tracking
      mkdir "$moveDir"
      chmod 777 "$moveDir"
    fi
    #Make the Season folder if it is applicable and does not exist
    if [ "$Season" != "" ] && [ $progId != "MV" ]; then
      moveDir="$moveDir/Season $Season" 
      if [ ! -d "$moveDir" ]; then
        mkdir "$moveDir" 
        chmod 777 "$moveDir"
        echo "$moveDir">>"$workingDir"/dir.tracking
      fi
    fi
  fi
  
  #Error message if folder was not created
  if [ ! -d "$moveDir" ]; then
    echo "COULD NOT CREATE $moveDir/$InputTitle">>"$workingDir"/output.log
  fi
}

#####End Functions######

####Start Main####

InputPath=$1

InputFileBasename=$(basename "$InputPath")
extension="${InputFileBasename##*.}"
filename="${InputFileBasename%.*}"
recpath="$(dirname $InputPath)"

#Create working directory
if [ ! -d "$workingDir" ]; then
        mkdir "$workingDir"
fi

#Convert recording if enabled
if [ "$convert" == "Enabled" ]; then
  ConvertRecording
fi

#Pull recording information from mythconverg database
GetRecordingInfo

#universally not accepted file system characters:  |\?*<":>+[]/ 
#Format Shows
#EpisodeSubtitle=`echo $EpisodeSubtitle| tr -d '!|\?*<":>+[]/'"'"`
#NewShowName=`echo $NewShowName|tr -d '!|\?*<":>+[]/'"'"`
ShowName=`echo $InputTitle|tr -d '!|\?*<":>+[]/'"'"`
#SafeShowName=`echo "$ShowName"|sed 's/;.*//'|tr -d '|\?*<":>+[]/'`
#Format Show name for Sending to www.TheTvDb.com and XBMC
tvdbshowname=`echo $ShowName | sed s/" "/"%20"/g|sed s/"&"/"%26"/g`

if [ $progId == "MV" ]; then
  CreateFileName
  MakeShowDir
else
  GetSeriesId
  GetXMLZip
  GetSeasonAndEpisodeInfo
  CreateFileName
  MakeShowDir
fi

#create the symlink to the show directory
ln -s "$InputPath" "$moveDir/$progfilename"
echo "Moved $InputPath to $moveDir/$progfilename"

if [ "$InputSubtitle" != "" ]; then
  episodename="$InputTitle - $SE - $InputSubtitle"
else
  episodename="$InputTitle - $SE - $filename"
fi

#Output commercial data to initial file
if [ "$comskip" == "Enabled" ]; then
  RunComskip
fi

#Create series and episode nfo file if they don't exist
if [ ! -f "$moveDir/tvshow.xml" ]; then
  CreateSeriesNFO
fi

if [ ! -f "$moveDir/$episodename.nfo" ]; then
  CreateEpisodeNFO
fi

#Download the fanart, poster and banner from thetvdb.com
DownloadFanart

##UpdateKodi
#####End Main#####
